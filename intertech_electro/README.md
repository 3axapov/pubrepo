# Тестовое задание: Docker, Docker Compose, CI/CD

## Описание проекта
Проект представляет собой гибридную систему, совмещающую старую и новую части системы (на legacy- и современном стеке, соответственно).  
Основная цель — обеспечить бесперебойную работу старой реализации (PHP 7, Symfony 3.4) и обеспечить постепенный переход на современное решение (PHP 8, Symfony + API Platform), сохраняя обратную совместимость.

## Цель
Развернуть инфраструктуру проекта с использованием Docker и Docker Compose, обеспечить взаимодействие между старым/новым API, фронтендами, БД и прочими компонентами системы.

## Архитектура системы

### 1. Legacy-система (старое API и фронтенд):
1. Монолит на **PHP 7.4** с фронтендом, собираемым через Webpack.  
2. Использует **Redis** для кэширования.

### 2. Новая система:
#### API:
1. Реализовано на **Symfony (PHP 8.4)** с использованием **API Platform**.  
2. Проксирует часть запросов к старому API.  
3. Использует **Redis** для кэширования.  
4. Использует **RabbitMQ** для асинхронной генерации отчетов.  

#### Фронтенд:
1. SPA-приложение (**React**).  
2. Взаимодействует только с новым API.  

### 3. База данных
- **MariaDB**  
- Общая база для обеих систем, контроль доступа и разрешение конфликтов осуществляется на уровне приложений и не входит в сферу ответственности инфраструктурного решения.  

### 4. Сервис идентификации
- **Keycloak**  
- Сервис обеспечивает единую точку входа для обеих систем (**SSO**).  
- За счёт использования **JWT** обеспечивается прозрачный обмен напрямую по API для старой и новой систем.  

### 5. Инфраструктура  
(приведено для информации, считается, что сервисы уже функционируют; можно учитывать это при выборе конфигурации целевой системы):

1. Система контроля версий — **GitLab**  
2. **CI/CD** — Jenkins  
3. Сбор логов — **Graylog**  
4. Мониторинг — **Zabbix / Grafana**  

Дополнительно можно предложить инфраструктурные компоненты, которые помогут решить задачу (например, реестр образов Docker).

# Общие моменты
1. Все системы, взаимодействующие с пользователем, находятся за **Gateway (Nginx)**, привести пример настройки:
   1. роутов,  
   2. отдачи статики,  
   3. SSL.  
2. При выборе решения учитывать, что важна **надёжность хранения данных**.  
3. Целевая система не высоконагруженная, но при этом должна быть готова к тяжёлым запросам к БД (аналитические запросы).  
4. Используем **лучшие практики**.  

---

# Задачи
1. Создать Docker-образы для:
   1. Старого API (**PHP 7.4 / Symfony + фронтенд на Webpack**).  
   2. Нового API (**PHP 8.4 / Symfony**).  
   3. Фронтенда (статическая сборка через **Node.js + Webpack**).  

2. Настроить `docker-compose.yml`.  

3. Добавить в проект пайплайн **CI/CD** (*Jenkins или GitLab CI на выбор*), который:
   1. Собирает Docker-образы для всех сервисов.  
   2. Запускает юнит-тесты для PHP-проектов.  
   3. Деплоит обновлённые контейнеры в тестовое окружение.  

---

# Вопросы
1. Как обеспечить работу нескольких окружений (**prod, staging, test**) в предложенном решении?  
2. Как обеспечить деплоймент?  
3. Как обеспечить работу миграций БД?  
4. Как организовать управление **SSL-сертификатами**?  
5. Мы используем Redis в старой и новой системах. Как развернуть Redis: сделать общим или для каждой системы запустить отдельно? Почему?  

---

# Требования к реализации
1. Требования к **Dockerfile**:
   - Оптимизация через многослойные сборки.  
   - Установка зависимостей через Composer (для PHP).  

2. Привести конфигурацию **Nginx**.  

3. Переменные окружения:
   - Все настройки (DB credentials, JWT secret, Redis host) вынесены в `.env`.  

---

# Ожидаемый результат
- Проект с кодом (**Symfony + Docker**).  
- Инструкция по запуску.  